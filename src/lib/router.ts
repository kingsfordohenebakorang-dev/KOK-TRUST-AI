import { solveActuarialProblem } from './sympy';
import { graphService } from './graph';

export enum QueryType {
    COMPUTATIONAL = 'COMPUTATIONAL',
    CONCEPTUAL = 'CONCEPTUAL',
    HYBRID = 'HYBRID'
}

export interface RouterResponse {
    type: QueryType;
    steps: any[];
    graph_context?: any;
    final_answer: string;
    source: string;
    content?: string;
}

export class QueryRouter {

    classify(query: string): QueryType {
        const q = query.toLowerCase();

        // Simple heuristic classifier
        if (q.includes('calculate') || q.includes('solve') || q.includes('value of')) {
            if (q.includes('explain') || q.includes('why')) {
                return QueryType.HYBRID;
            }
            return QueryType.COMPUTATIONAL;
        }

        if (q.includes('what is') || q.includes('model') || q.includes('concept')) {
            return QueryType.CONCEPTUAL;
        }

        return QueryType.HYBRID; // Default fall back
    }

    async process(query: string, mode: string = 'study'): Promise<RouterResponse> {
        if (mode === 'tutor') {
            // Simulate Actuarial Tutor Response
            console.log(`[Router] Processing query in TUTOR mode`);
            await new Promise(resolve => setTimeout(resolve, 2000)); // Thinking time

            const q = query.toLowerCase();
            let content = '';

            if (q.includes('variance') && q.includes('annuity')) {
                content = `
### 1. Problem Statement
Calculate the variance of the present value random variable for a whole life annuity-due of 1 per year issued to (x).

### 2. Variables and Assumptions
- Let $Y$ be the present value random variable.
- Let $K_x$ be the curtate future lifetime of (x).
- Interest rate $i$ is constant. $v = 1/(1+i)$.
- Benefit is 1 per year at the beginning of each year while (x) survives.
$$ Y = \\ddot{a}_{\\overline{K_x+1}|} $$

### 3. Derivation
We know that:
$$ \\ddot{a}_{\\overline{K_x+1}|} = \\frac{1 - v^{K_x+1}}{d} $$
Thus, the variance is:
$$ Var(Y) = Var\\left( \\frac{1 - v^{K_x+1}}{d} \\right) $$
Pulling out the constant $1/d$:
$$ Var(Y) = \\frac{1}{d^2} Var(1 - v^{K_x+1}) $$
Since $Var(aX + b) = a^2 Var(X)$, and constants have 0 variance:
$$ Var(Y) = \\frac{1}{d^2} Var(v^{K_x+1}) $$
Recall the definition of actuarial symbols:
$$ E[v^{K_x+1}] = A_x $$
$$ E[(v^{K_x+1})^2] = E[v^{2(K_x+1)}] = {}^2A_x $$
Therefore:
$$ Var(v^{K_x+1}) = E[(v^{K_x+1})^2] - (E[v^{K_x+1}])^2 = {}^2A_x - (A_x)^2 $$

### 4. Final Result
$$ \\boxed{ Var(Y) = \\frac{{}^2A_x - (A_x)^2}{d^2} } $$

### Summary
The variance of an annuity is derived from the variance of the insurance benefit, scaled by the discount rate squared. This relationship is crucial for understanding the dispersion of annuity costs.

### Practice Question
Derive the variance for a temporary life annuity-due of term $n$.
            `;
            } else {
                content = `
### 1. Problem Statement
Determine the value or derivation for: "${query}".

### 2. General Approach
- Identify the key actuarial concepts (e.g., Time Value of Money, Survival Models).
- Define the random variable $Z$ or $Y$.
- Apply the appropriate expectation or variance operators.

### 3. Derivation Template
Assume a standard standard actuarial model.
$$ Value = E[PV(Benefits)] - E[PV(Premiums)] $$
For numerical queries, we would plug in specific mortality table values (e.g., SULT or ELT-15).

### 4. Result
$$ \\boxed{ \\text{See derivation above} } $$

*(Note: In a real implementation with LLM access, this would be a specific solution generated by the model.)*

### Summary
Actuarial problems often reduce to finding the first and second moments of the present value random variable.

### Practice Question
Try calculating the Net Single Premium for a 10-year endowment assurance.
            `;
            }

            return {
                type: QueryType.CONCEPTUAL,
                steps: [], // Tutor mode uses markdown content, not steps
                final_answer: '',
                source: 'Actuarial Tutor Engine',
                content: content
            }; // The content will be handled in the route wrapper or added here? 
            // Wait, RouterResponse doesn't have content, the Route adds it. 
            // I should return the content in RouterResponse or handle it in the route.
            // Let's add content to RouterResponse to pass it through.
        }

        const type = this.classify(query);
        console.log(`[Router] Processing query as ${type}`);

        let steps = [];
        let final_answer = '';
        let graph_context = null;
        let source = 'General Knowledge';

        switch (type) {
            case QueryType.COMPUTATIONAL:
            case QueryType.HYBRID:
                // Execute Symbolic Solver (Sprint 2 Logic)
                const mathResult = await solveActuarialProblem(query);
                steps = mathResult.steps;
                final_answer = mathResult.final_answer;
                source = mathResult.source;

                // If Hybrid, fetch context
                if (type === QueryType.HYBRID) {
                    // Extract keywords (naive) -> 'variance', 'annuity'
                    const keywords = query.split(' ').filter(w => w.length > 5);
                    // Query Graph Service for first keyword found
                    if (keywords.length > 0) {
                        graph_context = await graphService.queryConcept(keywords[0]);
                    }
                }
                break;

            case QueryType.CONCEPTUAL:
                // Pure Graph Retrieval
                const concepts = await graphService.queryConcept(query);
                graph_context = concepts;
                source = 'Actuarial Knowledge Graph';
                final_answer = `Found ${concepts.nodes.length} related concepts in the Knowledge Graph.`;
                steps = concepts.nodes.map(n => ({
                    id: n.id,
                    latex: n.label === 'Formula' ? n.name : '',
                    explanation: `${n.label}: ${n.name}`
                }));
                break;
        }

        return {
            type,
            steps,
            graph_context,
            final_answer,
            source
        };
    }
}

export const router = new QueryRouter();
